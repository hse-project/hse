#!/usr/bin/awk -f

# SPDX-License-Identifier: Apache-2.0
#
# Copyright (C) 2021-2022 Micron Technology, Inc. All rights reserved.


# Given a C header file annotated for pre-processing for NF Unit Testing,
# create the auxiliary output files to provide the mocking capability.
#
# Note - This probably won't work in the full generic gcc function
#        declaration syntax with attributes, etc.
#
#        [HSE_REVISIT]

function init(i)
{
    LAST_FILENAME="";

    g_in_mock_def      = 0;

    for (i = 1; i < ARGC; i++) {
        if (ARGV[i] == "-h") {
            HEADER_MODE = 1;
            ARGV[i] = "";
        } else if (ARGV[i] == "-c") {
            SOURCE_MODE = 1;
            ARGV[i] = "";
        } else if (ARGV[i] == "-m") {
            ENUM_MODE = 1;
            ARGV[i] = "";
        } else if (ARGV[i] == "-o") {
          TARGET_FILE = ARGV[i+1];
          ARGV[i]   = "";
          ARGV[i+1] = "";
          i++;
        } else if (ARGV[i] ~ /^-./)
          usage(sprintf("error: %s - unrecognized option -- %s\n",
                        ARGV[0], substr(ARGV[i], 2, 1)));
        else
          break;
        delete ARGV[i];
    }
    if (HEADER_MODE + SOURCE_MODE + ENUM_MODE != 1)
      usage("error: must specify (only) one of -h, -c or -m");
    if (ENUM_MODE == 0 && TARGET_FILE == "")
      usage("error: must specify target output file");

    if (TARGET_FILE != "") {
        printf("/* HSE GENERATED FILE: DO NOT EDIT. %s\n",
                    "Generated by scripts/build/utpp */\n") > TARGET_FILE
    }
}

function fini()
{
    if (length(g_mock_func_names) > 0)
        process_functions(g_mock_func_names,
            g_mock_func_prefixes,
            g_mock_func_args,
            g_mock_set_names);
}

function usage(msg,
               usage_str) # local_vars
{
    printf("%s\n\n", msg) > "/dev/stderr";
    printf("%s\n", "Usage:") > "/dev/stderr";
    printf("%s\n", "  utpp -- -h -o <output file> <input file>") > "/dev/stderr";
    printf("%s\n", "  utpp -- -c -o <output file> <input file>") > "/dev/stderr";
    printf("%s\n", "  utpp -- -m <input file>  # writes to stdout") > "/dev/stderr";

    exit 1;
}

function die(msg)
{
    printf("utpp: error at %s:%d:\n%s\n",
        FILENAME, FNR, msg) > "/dev/stderr";
    exit 1;
}

function func_decl_parse(func_decl, func_def, mock_set,
                         res, tmp_str) # local vars
{
    # find the function name and argument list ...
    res = match(func_decl, /[[:alpha:]_][[:alnum:]_]*[ \t\n]*\(.*\)[ \t\n]*;/);
    if (res == 0)
        die(sprintf("error: bad function declaration: %s\n", func_decl));

    # pull out the entire prefix which should just be the return type ...
    tmp_str = substr(func_decl, 1, RSTART-1);
    gsub(/^[ \t]+/, "", tmp_str);
    gsub(/[ \t]+$/, "", tmp_str);
    gsub(/[ \t]+/, " ", tmp_str);
    gsub(/^\/\*/, "", tmp_str);
    func_def["prefix"] = tmp_str;

    # pull out the function name ...
    tmp_str = substr(func_decl, RSTART, RLENGTH);
    res = match(tmp_str, /[[:alpha:]_][[:alnum:]_]*/);
    if (res == 0)
        die("error: bad function name: $tmp_str")
    func_def["name"] = substr(tmp_str, RSTART, RLENGTH);

    # pull out the function argument specification ...
    res = match(tmp_str, /\(.*\)/);
    if (res == 0)
        die("error: bad function arguments: $tmp_str")
    tmp_str = substr(tmp_str, RSTART, RLENGTH);
    gsub(/\(/, "", tmp_str);
    gsub(/\)/, "", tmp_str);
    gsub(/^[ \t]+/, "", tmp_str);
    gsub(/[ \t]+$/, "", tmp_str);
    gsub(/[ \t]+/, " ", tmp_str);
    func_def["args"] = tmp_str;

    func_def["set_name"] = mock_set;
}

function extract_mock_set_name(mock_set_decl,
                               res, tmp_str) # local vars
{
    # extract MTF_MOCK_DECL(<set name>) ...
    res = match(mock_set_decl, /MTF_MOCK_DECL.*\(.*\)/);
    if (res == 0)
        die(sprintf("error: bad mockable declaration: %s\n", mock_set_decl));
    tmp_str = substr(mock_set_decl, RSTART, RLENGTH);

    # get rid of the opening and closing parentheses
    res = match(tmp_str, /\(.*\)/);
    if (res == 0)
        die(sprintf("error: bad mockable declaration: %s\n", mock_set_decl));
    tmp_str = substr(tmp_str, RSTART+1, RLENGTH-2);

    # get rid of any whitespace
    gsub(/^[ \t]+/, "", tmp_str);
    if (match(tmp_str, /[[:alpha:]_][[:alnum:]_]*/)) {
        tmp_str = substr(tmp_str, RSTART, RLENGTH);
        return tmp_str;
    }
    else
      die(sprintf("error: bad mockable declaration: %s\n", mock_set_decl))
}

function emit_header(name, set_name, prefix, args)
{
    if (++first_time_mock == 1) {
        printf("#include <stdint.h>\n\n") > TARGET_FILE;
        printf("#include <mock/api.h>\n") > TARGET_FILE;
    }

    printf("\n\n/* %s\n */\n", name) > TARGET_FILE;

    printf("typedef %s (*mtfm_%s_%s_fp)(%s);\n",
            prefix, set_name, name, args) > TARGET_FILE;

    printf("mtfm_%s_%s_fp  mtfm_%s_%s_get(void);\n",
            set_name, name, set_name, name) > TARGET_FILE;

    printf("mtfm_%s_%s_fp  mtfm_%s_%s_getreal(void);\n\n",
            set_name, name, set_name, name)  > TARGET_FILE;

    warn=0

    printf("#ifndef MTF_MOCK_IMPL_%s\n", set_name) > TARGET_FILE;
    printf("#define %s(...) \\\n", name) > TARGET_FILE;
    printf("({ \\\n") > TARGET_FILE;

    if (prefix == "void") {
        printf("\tif (!mapi_enabled || !mapi_inject_check(%s%s, 0)) \\\n",
            "mapi_idx_", name) > TARGET_FILE;
        printf("\t\t(mtfm_%s_%s_get())(__VA_ARGS__); \\\n",
            set_name, name) > TARGET_FILE;
        printf("\t(void)0; \\\n") > TARGET_FILE;
    } else if (prefix ~ /\*$/) {
        printf("\tvoid *rc = NULL; \\\n") > TARGET_FILE;
        printf("\tif (!mapi_enabled || !mapi_inject_check_ptr(%s%s, &rc)) \\\n",
            "mapi_idx_", name) > TARGET_FILE;
        printf("\t\trc = (void *)(mtfm_%s_%s_get())(__VA_ARGS__); \\\n",
            set_name, name) > TARGET_FILE;
        printf("\trc; \\\n") > TARGET_FILE;
    } else if (prefix ~ /bool|int|uint|unsigned|unsigned int|long|ulong|merr_t|size_t|ssize_t|enum|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t/) {
        printf("\tuint64_t rc = 0; \\\n") > TARGET_FILE;
        printf("\tif (!mapi_enabled || !mapi_inject_check(%s%s, &rc)) \\\n",
            "mapi_idx_", name) > TARGET_FILE;
        printf("\t\trc = (mtfm_%s_%s_get())(__VA_ARGS__); \\\n",
            set_name, name) > TARGET_FILE;
        printf("\trc; \\\n") > TARGET_FILE;
    } else {
        printf("\t(mtfm_%s_%s_get())(__VA_ARGS__); \\\n",
            set_name, name) > TARGET_FILE;
        warn=1
    }

    printf("})\n") > TARGET_FILE;
    if (warn) {
        printf("//#warning \"!!! %s: unhandled return type %s !!!\"\n",
                name, prefix) > TARGET_FILE;
    }
    printf("#endif /* MTF_MOCK_IMPL_%s */\n\n", set_name) > TARGET_FILE;

    printf("void mtfm_%s_%s_set(%s (*mock)(%s));\n",
        set_name, name, prefix, args) > TARGET_FILE;
}

function emit_ops_definition(set_name, ops_elmnts, ops_inits)
{
    printf("struct mtfm_%s_ops {\n", set_name) > TARGET_FILE;
    printf("%s", ops_elmnts) > TARGET_FILE;
    printf("} mtfm_%s_ops = {\n", set_name) > TARGET_FILE;
    printf("%s};\n\n", ops_inits) > TARGET_FILE;
}

function fmt_ops_elmnt(name, prefix, args)
{
    return sprintf("\t%s (*%s)(%s);\n", prefix, name, args);
}

function fmt_ops_init(name)
{
    return sprintf("\t.%s = NULL,\n", name);
}

function fmt_mock_methods(name, set_name, prefix, args,
                          res) # local vars
{
    res = ""
    res = res sprintf("mtfm_%s_%s_fp\nmtfm_%s_%s_get(void)\n{\n",
                  set_name, name, set_name, name);
    res = res sprintf("\tif (mtfm_%s_ops.%s)\n",
                      set_name, name);
    res = res sprintf("\t\treturn mtfm_%s_ops.%s;\n",
                      set_name, name);
    res = res sprintf("\n\treturn %s;\n", name);
    res = res sprintf("}\n");

    res = res sprintf("mtfm_%s_%s_fp\nmtfm_%s_%s_getreal(void)\n{\n",
                      set_name, name, set_name, name);
    res = res sprintf("\treturn %s;\n", name);
    res = res sprintf("}\n");

    res = res sprintf("void\nmtfm_%s_%s_set(\n\t%s (*mock)(%s))\n{\n",
                      set_name, name, prefix, args);
    res = res sprintf("\tmtfm_%s_ops.%s = mock;\n}\n",
                      set_name, name);

    return res;
}

function process_functions(func_names,
                           func_prefixes, func_args,
                           func_set_names,
                           name, prefix, args, # local vars
                           key, set_name, set_names,
                           ops_elmnts, ops_inits,
                           new_str, methods,
                           set_name_func_set)
{
    if (length(func_names) == 0) {
        printf("we are here\n")
        return;
    }

    # create a dictionary containing all MTF_MOCK_DECL set names
    for (key in func_set_names)
        set_names[func_set_names[key]] = 1;

    # traverse that dictionary ...
    for (set_name in set_names) {
        # create a set containing all func names for the current set name
        for (name in func_names)
            if (set_name == func_set_names[name])
                set_name_func_set[func_names[name]] = 1;

        # empty the strings where code is accumulated
        ops_elmnts = "";
        ops_inits  = "";
        methods    = "";

        if (HEADER_MODE) {
            # Prepare and print a guard ifdef in the header file
            unique_str=toupper(TARGET_FILE)
            gsub("/", "_", unique_str)
            gsub(/\./, "_", unique_str)
            gsub(/\-/, "_", unique_str)
            gsub(/@/, "_", unique_str)
            printf("#ifndef %s\n", unique_str) > TARGET_FILE;
            printf("#define %s\n\n", unique_str) > TARGET_FILE;

            for (name in set_name_func_set) {
                prefix = func_prefixes[name];
                name   = func_names[name];
                args   = func_args[name];

                emit_header(name, set_name, prefix, args);
            }
            # Terminate the guard ifdef in the header file
            printf("\n#endif /* %s */\n", unique_str) > TARGET_FILE;
        } else if (ENUM_MODE) {
            for (name in set_name_func_set) {
                prefix = func_prefixes[name];
                name   = func_names[name];
                args   = func_args[name];

                split(name, a, "|")
                print a[1]
                print a[2]
            }
        } else {
            #
            # For each set_name we need to define the "ops" structure
            # that is a virtual function table containing re-writable
            # slots for each mockable method. We also need to provide the
            # associated function definitions ("methods" below) for
            # modifying those slots.
            #

            # loop over just the functions in the set_name_func_set ...
            for (name in set_name_func_set) {
                prefix = func_prefixes[name];
                name   = func_names[name];
                args   = func_args[name];

                # accumulate the code to declare the methods
                methods = methods fmt_mock_methods(name,
                                                   set_name, prefix, args);

                # accumulate the code to declare the elements
                new_str = fmt_ops_elmnt(name, prefix, args);
                ops_elmnts = ops_elmnts new_str;

                # ... and the code to initialize those elements
                new_str = fmt_ops_init(name);
                ops_inits  = ops_inits new_str;
            }
            emit_ops_definition(set_name, ops_elmnts, ops_inits);
            printf("%s", methods) > TARGET_FILE;
        }

        # the set is no longer needed
        delete set_name_func_set;
    }

    delete func_prefixes;
    delete func_names;
    delete func_args;
}

function process_func_decl_input(input,
                                 i, fields, num_fields, tmp, # local vars
                                 func_name, func_set_name,
                                 func_prefix, func_args,
                                 func_elements)
{
    # look for an opening parenthesis ...
    split(input, fields, "(");
    num_fields = length(fields);

    if (num_fields > 1) {
        # found it ...
        if (g_paren_level == 0)
            g_paren_start = 1;
        g_paren_level++;
    }

    for (i = 1; i <= num_fields; i++) {
        tmp = fields[i]
        # look for the closing parenthesis ...
        g_paren_level -= gsub(")", "", tmp);
        if (g_paren_level < 0)
            die("unbalanced parentheses near $fn_decl")

        if (g_paren_start == 1 && g_paren_level == 0) {
            # Saw an open parenthesis and found its matching close parethesis,
            # so at this point we've got the entire function declaration
            tmp = fields[i];
            if ($tmp ~ /)[ \t\n]*;/) {
                delete func_elements;
                func_decl_parse(g_func_decl, func_elements, g_mock_set);

                if ("prefix" in func_elements)
                    func_prefix = func_elements["prefix"];
                else
                    die("error: failed parsing function declaration: $func_decl")

                if ("name" in func_elements)
                    func_name = func_elements["name"];
                else
                    die("error: failed parsing function declaration: $func_decl")

                if ("args" in func_elements)
                    func_args = func_elements["args"];
                else
                    die("error: failed parsing function declaration: $func_decl")

                func_set_name = func_elements["set_name"];

                g_mock_set_names[func_name]     = func_set_name;
                g_mock_func_prefixes[func_name] = func_prefix;
                g_mock_func_names[func_name]    = func_name;
                g_mock_func_args[func_name]     = func_args;

                return 1;
            }
        }
    }

    return 0;
}

function process_mock_def(input,
                          res)
{
    res = process_func_decl_input(input);
    if (res)
        g_in_mock_def = 0;
}

#
# Match /* MTF_MOCK_DECL(<set name>) */ with whitespace variations ...
#
/^[[:blank:]]*\/[*].*MTF_MOCK_DECL[ \t]*\(.*\)[ \t]*[*]\// {
    g_in_mock_set   = 1;
    g_mock_set_name = extract_mock_set_name($0);
    next
}

#
# Match /* MTF_MOCK */ with whitespace variations ...
#
/^[[:blank:]]*\/[*].*MTF_MOCK[^_][ \t]*.*[*]\// {
    if (!g_in_mock_set)
        die("error: MTF_MOCK declaration before MTF_MOCK_DECL(<set name>)")
    g_in_mock_def = 1;
    g_paren_level = 0;
    g_mock_set    = g_mock_set_name
    g_func_decl   = "";
    g_paren_start = 0;
    next
}

# match everything ...
{
    # discard if we're not processing a mockable entry point ...
    if (!g_in_mock_def)
        next

    gsub(/\n/, "", $0);

    # accumulate the function declaration text ...
    g_func_decl = g_func_decl " " $0

    process_mock_def($0)
}

BEGIN {
    init()
}

END {
    fini()
}
