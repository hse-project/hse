#!/usr/bin/env python3

import argparse
import os
import pathlib
from typing import TYPE_CHECKING, cast

if TYPE_CHECKING:
    from typing import Protocol, Optional

    class Arguments(Protocol):
        name: Optional[str]
        input: pathlib.Path
        output: pathlib.Path


parser = argparse.ArgumentParser(
    description="Convert a file into a C-style header file similar to xxd"
)
parser.add_argument("-n", "--name", help="Variable name")
parser.add_argument("input", type=pathlib.Path, help="Input file")
parser.add_argument("output", type=pathlib.Path, help="Output file")

args = cast("Arguments", parser.parse_args())

IDENT_FILE_NAME = str(args.input).replace(os.sep, "_").replace(".", "_")
VARIABLE_NAME = args.name if args.name else IDENT_FILE_NAME

inb = args.input.read_bytes()

with open(args.output, "w", encoding="utf-8") as outf:
    outf.write("/* Generated by includeify. DO NOT EDIT. */\n\n")
    outf.write(f"#ifndef {IDENT_FILE_NAME.upper()}_H\n")
    outf.write(f"#define {IDENT_FILE_NAME.upper()}_H\n\n")

    outf.write(f"const unsigned char {VARIABLE_NAME}[] = {{\n")

    for i, b in enumerate(inb):
        if i % 8 == 0:
            outf.write("\t")
        outf.write(f"{b:#04x},")
        if (i != 0 and i % 8 == 7) or i == len(inb) - 1:
            outf.write("\n")
        else:
            outf.write(" ")

    outf.write("};\n\n")

    outf.write("#endif\n")
